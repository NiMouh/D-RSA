import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.Arrays;
import java.util.Base64;

import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;

import java.io.*;

public class rsa {
    public static final String PBKDF2_ALGORITHM = "PBKDF2WithHmacSHA256";
    public static final int SIZE_STREAM = 4096; // Tamanho da chave RSA
    public static final int ITERATIONS = 10; // Número máximo de iterações
    public static final String PASSWORD = "password";
    public static final String CONFUSION_STRING = "abc";
    public static final int SEED =  32; // Tamanho da seed em bytes
    public static final int SHA256_DIGEST_LENGTH = 32; // Tamanho do output do SHA-256 em bytes
    public static final int PRIME_SIZE = 256; // Tamanho dos primos p e q em bits
    public static final BigInteger e = BigInteger.valueOf(65537); // Valor de e
    
    public static void main(String[] args) throws Exception {
        
        // Generate random stream of bytes
        byte[] random_stream_bytes = randgen(PASSWORD, CONFUSION_STRING, ITERATIONS, SIZE_STREAM);

        byte[] firstBytes = Arrays.copyOfRange(random_stream_bytes, 0, PRIME_SIZE);

        // Generate the key pair
        BigInteger[][] keyPair = rsagen(firstBytes);

        // Store the key pair in files
        storeKeyPair(keyPair);
    }

    public static byte[] generateRandomBytes(int streamSize, byte[] seed) {
        try {
            MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
            byte[] stream = new byte[streamSize];

            for (int index = 0; index < streamSize; index += SHA256_DIGEST_LENGTH) {
                // Use SHA-256 to hash the seed
                byte[] hashOutput = sha256.digest(seed);

                // Copy the hash output to the stream
                int bytesToCopy = (index + SHA256_DIGEST_LENGTH > streamSize) ? streamSize - index : SHA256_DIGEST_LENGTH;
                
                // Copy the hash output to the stream
                System.arraycopy(hashOutput, 0, stream, index, bytesToCopy);

                // Update the seed with the hash output for the next iteration
                System.arraycopy(hashOutput, 0, seed, 0, SHA256_DIGEST_LENGTH);

            }
            return stream;
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace(); // Handle the exception appropriately
            return null;
        }
    }

    public static String encodeToBase64(byte[] data) {
        return Base64.getEncoder().encodeToString(data);
    }

    public static boolean verificarPadrao(byte[] A, byte[] B) {

        if(A.length > B.length){
            System.out.println("A is bigger than B");
            return false;
        }

        for (int i = 0; i <= B.length - A.length; i++) {
            int j;
            for (j = 0; j < A.length; j++) {
                if (B[i + j] != A[j]) {
                    break;
                }
            }
            if(j == A.length){
                return true;
            }
        }   
        return false;
    }
    
    public static byte[] randgen(String password, String confusionString, int iterations, int size)
            throws NoSuchAlgorithmException, InvalidKeySpecException {
        // Converter a string de confusão e a senha em arrays de bytes e arrays de char respetivamente
        char[] passwordChar = password.toCharArray();

        // Derivar a chave usando PBKDF2 com a senha, o salt que é numa maneira inicial, a confusion string e o número de iterações
        PBEKeySpec spec = new PBEKeySpec(passwordChar, confusionString.getBytes(), iterations, (SEED + confusionString.length()) * 8); //256 bits para a chave
        SecretKeyFactory skf = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM);
        byte[] key_derivator = skf.generateSecret(spec).getEncoded();

        // Cortar a chave derivada para obter a seed
        byte[] bootstrapSeed = new byte[SEED];
        for(int i = 0; i < SEED; i++){
            bootstrapSeed[i] = key_derivator[i];
        }

        // Cortar a chave derivada para obter o padrão de confusão
        byte[] confusionPattern = new byte[confusionString.length()];
        for(int i = 0; i < confusionString.length(); i++){
            confusionPattern[i] = key_derivator[SEED + i];
        }

        byte[] stream = new byte[size];
        for(int iteration = 0; iteration < iterations; iteration++){
           while(true){
                stream = generateRandomBytes(size, bootstrapSeed);

                if(verificarPadrao(confusionPattern, stream)){
                    System.out.println("Found confusion string in generated bytes!");
                    break;
                }
           }
           // Get the last bytes of the stream for the bootstrap seed
            for(int i = 0; i < SEED; i++){
                bootstrapSeed[i] = stream[stream.length - SEED + i];
            }
        }
        return stream;
    }

    // Função auxiliar para remover o byte de sinal se existir
    public static byte[] removeSignByte(byte[] bytes) {
        if (bytes[0] == 0) {
            byte[] result = new byte[bytes.length - 1];
            System.arraycopy(bytes, 1, result, 0, result.length);
            return result;
        }
        return bytes;
    }

    public static byte[] generateDEREncodingPublic(BigInteger N, BigInteger e) {
        byte[] NBytes = removeSignByte(N.toByteArray()); // Remove byte de sinal se existir
        byte[] eBytes = removeSignByte(e.toByteArray()); // Remove byte de sinal se existir

        // Montando a estrutura DER
        int totalLength = 4 + NBytes.length + 2 + eBytes.length; // 4 bytes para cabeçalho + tamanho n + tamanho e
        byte[] derEncoding = new byte[totalLength];

        derEncoding[0] = 0x30; // Byte de início da sequência
        derEncoding[1] = (byte) (totalLength - 6); // Tamanho total do bloco n + e

        int index = 2;
        derEncoding[index++] = 0x02; // Byte de separação para n
        derEncoding[index++] = (byte) NBytes.length; // Tamanho de n

        // Copiar os bytes de n para a representação DER
        System.arraycopy(NBytes, 0, derEncoding, index, NBytes.length);
        index += NBytes.length;

        derEncoding[index++] = 0x02; // Byte de separação para e
        derEncoding[index++] = (byte) eBytes.length; // Tamanho de e

        // Copiar os bytes de e para a representação DER
        System.arraycopy(eBytes, 0, derEncoding, index, eBytes.length);

        return derEncoding;
    }

    public static byte[] generateDEREncodingPrivate(BigInteger n, BigInteger d) {
        byte[] NBytes = removeSignByte(n.toByteArray()); // Remove byte de sinal se existir
        byte[] dBytes = removeSignByte(d.toByteArray());

        System.out.println("dBytes length: " + dBytes.length);

        // Calculate total length for the DER encoding
        int totalLength = 6 + NBytes.length + dBytes.length;
        int index = 0;
        byte[] derEncoding = new byte[totalLength];

        derEncoding[index++] = 0x30; // Byte of sequence start
        derEncoding[index++] = (byte) (totalLength - 6); // Total block length

        derEncoding[index++] = 0x02; // Byte for p
        derEncoding[index++] = (byte) NBytes.length; // p size
        System.arraycopy(NBytes, 0, derEncoding, index, NBytes.length);
        index += NBytes.length;

        derEncoding[index++] = 0x02; // Byte for d
        derEncoding[index++] = (byte) dBytes.length; // d size
        System.arraycopy(dBytes, 0, derEncoding, index, dBytes.length);

        return derEncoding;
    }

    // Função auxiliar para converter bytes para representação hexadecimal
    public static String bytesToHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    }

    // Gerar o par de chaves RSA
    public static BigInteger[][] rsagen(byte[] random_stream_bytes) throws Exception {

        // Imprimir random stream em hexadecimal
        System.out.println("\n");
        System.out.println("Random Stream: " + bytesToHex(random_stream_bytes));
        System.out.println("\n");
        // Dividir o stream aleatório em duas partes p e q
        byte[] p_bytes = Arrays.copyOfRange(random_stream_bytes, 0, random_stream_bytes.length / 2);
        byte[] q_bytes = Arrays.copyOfRange(random_stream_bytes, random_stream_bytes.length / 2, random_stream_bytes.length);

        //tornar o p e q como bignumbers
        BigInteger p = new BigInteger(1, p_bytes);
        BigInteger q = new BigInteger(1, q_bytes);

        System.out.println("\n P e Q \n");
        for(byte i: p.toByteArray()) {
            System.out.format("%02X ", i);
        }
        System.out.println("\n");
        for(byte j: q.toByteArray()) {
            System.out.format("%02X ", j);
        }
        System.out.println("\n");
       

        System.out.println("\n NestProbablePrime \n");
        // Verifica se p não é primo
        while (!p.isProbablePrime(100)) {
            System.out.println("p não é primo");
            p = p.nextProbablePrime();
            
        }

        // Verifica se q não é primo
        while (!q.isProbablePrime(100)) {
            q = q.nextProbablePrime();
        }

        for(byte i: p.toByteArray()) {
            System.out.format("%02X ", i);
        }
        System.out.println("\n");
        for(byte j: q.toByteArray()) {
            System.out.format("%02X ", j);
        }
        System.out.println("\n"); 
        

        // Calcular o n
        BigInteger n = p.multiply(q);

        // Imprimir o n em hexadecimal
        System.out.println("n: " + bytesToHex(n.toByteArray()));

        // Calcular o phi
        BigInteger phi = p.subtract(BigInteger.ONE).multiply(q.subtract(BigInteger.ONE));

        // Calcular o d
        BigInteger d = e.modInverse(phi);
        
        // Representação DER para n e e
        byte[] derEncoding = generateDEREncodingPublic(n, e);

        // Imprimir a representação DER em formato hexadecimal
        System.out.println("DER Encoding (Public Key): " + bytesToHex(derEncoding));

        // Generate DER encoding for the private key
        byte[] derEncodingPrivate = generateDEREncodingPrivate(n, d);

        // Display DER encoding for the private key in hexadecimal format
        System.out.println("DER Encoding (Private Key): " + bytesToHex(derEncodingPrivate));

        // criar a chave publica pub=(n,e)
        BigInteger[] public_key = {n, e};

        // criar a minha chave privada priv=(n,d)
        BigInteger[] private_key = {n, d};

        //colocar num array o pub e priv
        BigInteger[][] keyPair = {public_key, private_key};

        return keyPair;
    }

    // Function that receives the keyPair and stores the private key in a file and the public key in another file (private_key.pem and public_key.pem)
    public static void storeKeyPair(BigInteger[][] keyPair) throws IOException {
        // Get the public key
        BigInteger[] public_key = keyPair[0];

        // juntar o n e o e num array de bytes
        byte[] public_key_bytes = generateDEREncodingPublic(public_key[0], public_key[1]);

        // codificar o array de bytes para base64
        String public_key_base64 = encodeToBase64(public_key_bytes);

        // imprimir a chave publica
        System.out.println("------BEGIN PUBLIC KEY------\n" + public_key_base64 + "\n------END PUBLIC KEY------\n");

        // Get the private key
        BigInteger[] private_key = keyPair[1];

        // juntar o n e o e num array de bytes
        byte[] private_key_bytes = generateDEREncodingPrivate(private_key[0], private_key[1]);

        // codificar o array de bytes para base64
        String private_key_base64 = encodeToBase64(private_key_bytes);

        // imprimir a chave privada
        System.out.println("------BEGIN PRIVATE KEY------\n" + private_key_base64 + "\n------END PRIVATE KEY------\n");

        // Store the public key in a file
        try (FileOutputStream outputStream = new FileOutputStream("public_key.pem")) {
            outputStream.write(public_key_base64.getBytes());
        }catch(Exception e){
            System.out.println("Erro ao escrever no ficheiro");
        }

        // Store the private key in a file
        try (FileOutputStream outputStream = new FileOutputStream("private_key.pem")) {
            outputStream.write(private_key_base64.getBytes());
        }catch(Exception e){
            System.out.println("Erro ao escrever no ficheiro");
        }
    }
}
